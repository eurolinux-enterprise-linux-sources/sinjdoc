package net.cscott.sinjdoc.parser;

import net.cscott.sinjdoc.lexer.Lexer;
import net.cscott.sinjdoc.ClassType;
import net.cscott.sinjdoc.Parameter;
import net.cscott.sinjdoc.ParameterizedType;
import net.cscott.sinjdoc.Type;
import net.cscott.sinjdoc.TypeArgument;
import net.cscott.sinjdoc.TypeVariable;
import java_cup.runtime.*;
import java.lang.reflect.Modifier;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/* Java 1.5 (JSR-14 + JSR-201) parser for CUP.
 * (Well, Java 1.5 as of 28 Jul 2003; it may change before official release)
 * Copyright (C) 2003 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JSR-14 Features added:
* parameterized types, including corrections from the spec released
  with the 2.2 prototype of the JSR-14 compiler.  Arrays of parameterized
  types bounded by wildcards are slated to be added to Java 1.5 (although
  they are not supported by the 2.2 prototype); this grammar supports them.
  "Wildcard" types are supported as of the 28 jul 2003 release.

JSR-201 Features added:
* no changes for autoboxing
* new-style for:
  foreach_statement ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement
	;
  foreach_statement_no_short_if ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement_no_short_if
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement_no_short_if
	;
  statement ::= ...
     |		foreach_statement ;
  statement_no_short_if ::= ...
     |		foreach_statement_no_short_if ;

* static import:
  static_single_type_import_declaration ::= 
		IMPORT STATIC name SEMICOLON
	;
  static_type_import_on_demand_declaration ::=
		IMPORT STATIC name DOT MULT SEMICOLON
	;
  import_declaration ::= ...
	|	static_single_type_import_declaration
	|	static_type_import_on_demand_declaration
	;
* varargs:
 formal_parameter ::= ...
	|	type ELLIPSIS IDENTIFIER
	|	FINAL type ELLIPSIS IDENTIFIER
	;
* enum:
  enum_declaration ::=
		modifiers_opt ENUM IDENTIFIER interfaces_opt enum_body
	;
  enum_body ::=
		LBRACE enum_constants_opt enum_body_declarations_opt RBRACE
	;
  enum_constants_opt ::=
	|	enum_constants
	;
  enum_constants ::=
		enum_constant
	|	enum_constants COMMA enum_constant
	;
  enum_constant ::=
		IDENTIFIER enum_arguments_opt
	|	IDENTIFIER enum_arguments_opt class_body
	;
  enum_arguments_opt ::=
	|	LPAREN argument_list_opt RPAREN
	;
  enum_body_declarations_opt ::=
	|	SEMICOLON class_body_declarations_opt
	;
*/
parser code  {: 
  PCompilationUnit compilationUnit;
  PRootDoc rootDoc;
  PPackageDoc expectedPackage;
  Lexer lexer;
  Stack<PClassDoc> outerClasses = new Stack<PClassDoc>();
  Stack<TypeContext> typeContexts = new Stack<TypeContext>();
  Map<String,PTypeVariable> additionalTypeVariables =
      new LinkedHashMap<String,PTypeVariable>();
  Map<String,Type> falseTypeVariables = new LinkedHashMap<String,Type>();
  boolean inTypeParamDecl=false;
  boolean isClassTypeVariable=false;
  private PSourcePosition startPos;
  int unnamedContext=0;
  int anonClassIndex=1;

  public Java15(PRootDoc rootDoc, File file, PPackageDoc expectedPackage)
      throws java.io.FileNotFoundException {
      this();
      this.compilationUnit = new PCompilationUnit(file);
      this.rootDoc = rootDoc;
      this.lexer = new Lexer
	  (new BufferedReader(FileUtil.fileReader
                              (file, rootDoc.pc.encoding, rootDoc)),
           rootDoc.pc.sourceVersion);
      this.startPos = new PSourcePosition(file, rootDoc.pc.encoding, true,
					  rootDoc);
      this.expectedPackage = expectedPackage;
  }

  public PSourcePosition sp(int leftPos) {
      return startPos.add(leftPos);
  }
  public void syntax_error(java_cup.runtime.Symbol current) {
      rootDoc.printError(sp(current.left), "Syntax error ("+current.sym+")");
  }
:};
action code {:
  public PSourcePosition sp(int leftPos) { return parser.sp(leftPos); }
  private static String combineWithDot(String a, String b) {
      return (a==null)?b:(b==null)?a:(a+"."+b);
  }
  /** Start an unnamed context: a method-local definition, or an anonymous
   *  class or interface. */
  private void startUnnamedContext() { parser.unnamedContext++; }
  /** End the unnamed context. */
  private void endUnnamedContext() { parser.unnamedContext--; }
  /** Determine if we are currently in an unnamed context. */
  private boolean isUnnamedContext() { return parser.unnamedContext > 0; }
  /** Return a new name string for an anonymouc class or context. */
  private String newAnonClassName() {
	return Integer.toString(parser.anonClassIndex++);
  }
  // before type parameters and superclass/interfaces declarations
  private void startTypeDeclaration(int modifiers, String name,
				    int class_type, int pos) {
      // Create classDoc object.
      PClassDoc outer = parser.outerClasses.empty() ?
	  null : parser.outerClasses.peek();
      // JLS 9.5: a member type declaration in an interface is implicitly
      // static and public.
      if (outer!=null && outer.isInterface())
	  modifiers |= Modifier.PUBLIC | Modifier.STATIC;
      // nested enum classes are implicitly static
      //  http://forum.java.sun.com/thread.jsp?forum=316&thread=438509
      if (outer!=null && class_type==Sym.ENUM)
	  modifiers |= Modifier.STATIC;

      // note that enum classes are 'ordinary classes' (as opposed to
      // interfaces) -- we don't invent a new 'enum class' type.
      PClassDoc cd = new PClassDoc(parser.rootDoc.pc, parser.expectedPackage,
				   parser.compilationUnit, outer, modifiers,
				   name, sp(pos), class_type==Sym.INTERFACE,
				   parser.lexer.lastComment(),
				   sp(parser.lexer.lastCommentPos()));
      parser.lexer.clearComment();
      // add to enclosing objects (package/class/compilation unit)
      if (!isUnnamedContext()) { // only if a named class.
	  if (outer!=null) outer.innerClasses.add(cd);
	  parser.expectedPackage.classes.add(cd.type());
	  parser.compilationUnit.classes.add(cd);
      } else newAnonClassName(); // a new anonymous context.
      // this is new outer class.
      parser.outerClasses.push(cd);
      // new environment scope for type variables.
      assert parser.additionalTypeVariables.isEmpty();
      assert !parser.inTypeParamDecl; // not yet in type parameter declaration
      parser.isClassTypeVariable=true; // type vars go in this class!
      // add implicit members and proper superclass to enum classes
      if (class_type==Sym.ENUM) fixupEnum(pos);
  }
  private void postTypeParam(PExecutableMemberDoc emd) {
      assert parser.isClassTypeVariable ? emd==null : emd!=null;
      assert !parser.inTypeParamDecl; // should be out of type param by now.
      // fixup false type parameters: go through bounds of type parameters
      // and substitute for false types.

      // create substitution map: false type variables to proper real types.
      Map<TypeVariable,Type> substMap = new HashMap<TypeVariable,Type>();
      for (Map.Entry<String,Type> ftvE : parser.falseTypeVariables.entrySet()){
	  String ftvName = ftvE.getKey();
	  PTypeVariable ftv = parser.additionalTypeVariables.get(ftvName);
	  parser.additionalTypeVariables.remove(ftvName);
	  assert ftv.bounds.size()==0;
	  Type realType = ftvE.getValue();
	  substMap.put(ftv, realType);
      }
      // now do substitution of real types for false type variables.
      for (PTypeVariable tv : parser.additionalTypeVariables.values()) {
	  assert tv.bounds.size() > 0;
	  // do the substitution
	  tv.setBounds(TypeUtil.subst(substMap, tv.getBounds()));
	  assert tv.bounds.size() > 0;
	  // finish init of class/method
	  if (emd!=null) { // finish init of method parameters.
	      PMethodTypeVariable mtv = (PMethodTypeVariable) tv;
	      mtv.declaringMethod = emd;
	      emd.typeParameters.add(mtv);
	  } else { // finish init of class parameters
	      PClassTypeVariable ctv = (PClassTypeVariable) tv;
	      parser.outerClasses.peek().typeParameters.add(ctv);
	  }
      }
      parser.additionalTypeVariables.clear(); // type vars now in class/method
      parser.falseTypeVariables.clear(); // reset for next.
      parser.isClassTypeVariable=false; // type vars now belong to some method
      parser.inTypeParamDecl=false; // no longer in type parameter declaration
  }
  // just before class body: start new type context.
  private void preClassBody() {
      assert parser.additionalTypeVariables.isEmpty();//should have been reset
      parser.typeContexts.push(parser.outerClasses.peek().typeContext);
  }
  // after class body
  private void endTypeDeclaration() {
      parser.typeContexts.pop();
      parser.outerClasses.pop();
  }
  private void fixupEnum(int pos) {
      // set the correct superclass.
      PClassDoc pcd = parser.outerClasses.peek();
      Type thisType = pcd.type();
      ClassType enumType = eagerClassType("java.lang","Enum");
      pcd.superclass = new PParameterizedType
	  (enumType, null, new TypeArgumentList(new PTypeArgument
						(thisType, false, false)));
      // add the implicit members of the class.
      int m = Modifier.PUBLIC | Modifier.FINAL;
      Type listType = new PParameterizedType
	  (eagerClassType("java.util","List"), null,
	   new TypeArgumentList(new PTypeArgument(thisType, false, false)));
      ClassType stringType = eagerClassType("java.lang","String");
      //    public static List<this enum class> VALUES;
      commentOverride="An immutable list containing the values comprising "+
	  "this enum class in the order they're declared.  This field may "+
	  "be used to iterate over the constants as follows: <pre>"+
	  "for("+pcd.name()+" c : "+pcd.name()+".VALUES)\n"+
	  "    System.out.println(c);</pre>";
      doFieldDeclaration(m | Modifier.STATIC, listType,
			 new VariableDeclaratorList
			 (new VariableDeclarator("VALUES", pos, parser)));
      //    public final List<this enum class> family();
      commentOverride="Returns an immutable list containing the values "+
	  "comprising this enum class in the order they're declared.  This "+
	  "instance method simply returns <code>VALUES</code>.  Few "+
	  "programmers should have any need to use this method.  It is "+
	  "provided for use by sophisticated enum-based data structures to "+
	  "prevent the need for reflective access to <code>VALUES</code>.\n"+
	  "@return an immutable list containing the values comprising this "+
	  "enum class, in the order they're declared.";
      doMethodDeclaration(m, listType, new MethodDeclarator
			  ("family", pos, new PParameterList()),
			  new TypeList());
      //    public static <this enum class> valueOf(String name);
      commentOverride="Static factory to return the enum constant pertaining "+
	  "to the given string name.  The string must match exactly an "+
	  "identifier used to declare an enum constant in this type.\n"+
	  "@throws IllegalArgumentException if this enum class has no "+
	  "constant with the specified name.";
      doMethodDeclaration(m | Modifier.STATIC, thisType, new MethodDeclarator
			  ("valueOf", pos, new PParameterList
			   (new PParameter(stringType, "name", false))),
			  new TypeList());
  }
  // enum constant declaration
  private void doEnumConstantDeclaration(String name, int pos) {
      int m = Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL;
      Type ty = parser.outerClasses.peek().type();
      List<VariableDeclarator> vdl = new VariableDeclaratorList
	  (new VariableDeclarator(name, pos, parser));
      doFieldDeclaration(m, ty, vdl);
  }
  private String commentOverride=null;
  // field declaration
  private void doFieldDeclaration(int modifiers, Type ty,
				  List<VariableDeclarator> variables) {
      // one comment string for all fields declared.
      String commentText = variables.get(0).comment;
      PSourcePosition commentPos = variables.get(0).commentPos;
      parser.lexer.clearComment();
      if (commentOverride!=null) { // allow "synthetic" comments
	  commentText=commentOverride; commentOverride=null;
      }
      // this is the class to which this field belongs.
      PClassDoc parent = parser.outerClasses.peek();
      // fields in interfaces are implicitly public. (JLS 6.6.1)
      if (parent.isInterface()) modifiers |= Modifier.PUBLIC;

      for (VariableDeclarator vd : variables) {
	  Type vty = arrayType(ty, vd.dims);
	  PFieldDoc fd = new PFieldDoc(parser.rootDoc.pc, parent,
				       modifiers, vty, vd.name, sp(vd.pos),
				       commentText, commentPos,
				       parser.typeContexts.peek());
	  parent.fields.add(fd);
      }
  }
  private void doMethodDeclaration(int modifiers, Type ty, MethodDeclarator md,
				   List<Type> thrownExceptions) {
      // doc comment for this method
      String commentText = parser.lexer.lastComment();
      PSourcePosition commentPos = sp(parser.lexer.lastCommentPos());
      parser.lexer.clearComment();
      if (commentOverride!=null) { // allow "synthetic" comments
	  commentText=commentOverride; commentOverride=null;
      }
      // this is the class to which this method belongs.
      PClassDoc parent = parser.outerClasses.peek();
      // methods in interfaces are implicitly public. (JLS 6.6.1)
      if (parent.isInterface()) modifiers |= Modifier.PUBLIC;
      // create the MethodDoc!
      PExecutableMemberDoc emd;
      if (md.name==null) { // constructor.
	  assert ty==null && md.dims==0; // constructors are void.
	  PConstructorDoc pcd =
	      new PConstructorDoc(parser.rootDoc.pc, parent, modifiers,
				  sp(md.pos), md.parameters,thrownExceptions,
				  commentText, commentPos,
				  parser.typeContexts.peek());
	  parent.constructors.add(pcd);
	  emd = pcd;
      } else { // method
	  PMethodDoc pmd =
	      new PMethodDoc(parser.rootDoc.pc, parent, modifiers,
			     arrayType(ty, md.dims), md.name, sp(md.pos),
			     md.parameters, thrownExceptions,
			     commentText, commentPos,
			     parser.typeContexts.peek());
	  parent.methods.add(pmd);
	  emd = pmd;
      }
      // fixup the MethodTypeVariables and add them to the MethodDoc
      postTypeParam(emd);
      // let's skip creating a new type context for the method.
  }

  ClassType eagerClassType(String pkgName, String clsName) {
      return new PEagerClassType(parser.rootDoc.pc, pkgName, clsName);
  }
  ClassType lookupClassType(String name) {
      return parser.typeContexts.peek().lookupClassTypeName(name,true/*lazy*/);
  }
  Type lookupType(String name) {
      // special case types named in type parameters: these may be forward
      // references.
      if (parser.additionalTypeVariables.containsKey(name) &&
	  (parser.inTypeParamDecl ||
	   !parser.falseTypeVariables.containsKey(name)))
	  return parser.additionalTypeVariables.get(name);
      else if (parser.inTypeParamDecl && name.indexOf('.')==-1) {
	  // make a 'false' type parameter.  we'll substitute out later
	  assert !parser.falseTypeVariables.containsKey(name);
	  createTypeVariable(name);
	  parser.falseTypeVariables.put
	      (name, parser.typeContexts.peek().lookupTypeName
	       (name, true/*lazy*/));
	  assert parser.additionalTypeVariables.containsKey(name);
	  return parser.additionalTypeVariables.get(name);
      }
      return parser.typeContexts.peek().lookupTypeName(name, true/*lazy*/);
  }
  ParameterizedType joinWithParam(ParameterizedType pt, String inner) {
      // divide and conquer if inner contains '.'
      int dot = inner.lastIndexOf('.');
      if (dot!=-1) {
	  pt = joinWithParam(pt, inner.substring(0, dot));
	  inner = inner.substring(dot+1);
      }
      // okay, now inner is dot-free
      assert inner.indexOf('.')==-1;
      return new PParameterizedType(new PLazyInnerClassType
				    (parser.rootDoc.pc, pt.getBaseType(),
				     inner), pt, new TypeArgumentList());
  }
  ParameterizedType addParams(Type ty, List<TypeArgument> typeArgs, int pos) {
      if (ty instanceof ParameterizedType) {
	  ParameterizedType pt = (ParameterizedType) ty;
	  assert pt.getActualTypeArguments().size()==0;
	  return new PParameterizedType(pt.getBaseType(),
					pt.getDeclaringType(),
					typeArgs);
      }
      if (ty instanceof TypeVariable) {
	  TypeVariable tv = (TypeVariable) ty;
	  if (parser.falseTypeVariables.containsKey(tv.getName()))
	      // xxx: might want to check that this 'false' type var isn't
	      // later made 'real'?
	      ty = parser.falseTypeVariables.get(tv.getName());
	  else {
	      parser.rootDoc.printError
		  (sp(pos), "Type variable "+tv+" cannot be parameterized");
	      // try to use var name as class name to continue.
	      ty = lookupClassType(tv.getName());
	  }
      }
      assert ty instanceof ClassType;
      ClassType ct = (ClassType) ty;
      // synthesize an outer class name.
      ClassType outer=null;
      if (ct instanceof PLazyInnerClassType)
	  outer = ((PLazyInnerClassType)ct).outerClass;
      else if (ct instanceof PEagerClassType) {
	  String typeName = ct.typeName();
	  int idx = typeName.lastIndexOf('.');
	  if (idx > 0)
	      outer = eagerClassType(((PEagerClassType)ct).packageName,
				     typeName.substring(0, idx));
      } else {
	  // XXX we need a lazy outer class type here.
      }
      return new PParameterizedType(ct, outer, typeArgs);
  }
  void addTypeVariable(String name) {
      assert name.indexOf('.')==-1;
      parser.inTypeParamDecl=true;
      // this type variable possibly already created as a 'false'
      // type variable (to handle forward reference).  Just mark the
      // existing false type var as real.
      if (parser.falseTypeVariables.containsKey(name))
	  // already created; mark as real.
	  parser.falseTypeVariables.remove(name);
      else
	  // create new type var.
	  createTypeVariable(name);
  }
  void createTypeVariable(String name) {
      assert name.indexOf('.')==-1 && parser.inTypeParamDecl;
      // are we in method or class context?
      if (parser.isClassTypeVariable) { // class context
	  PClassDoc parent = parser.outerClasses.peek();
	  PClassTypeVariable ctv = new PClassTypeVariable(parent, name);
	  parser.additionalTypeVariables.put(name, ctv);
	  // wait until postTypeParam() to add to parent, since this may
	  // end up being a false type variable.
      } else {  // method context
	  PMethodTypeVariable mtv = new PMethodTypeVariable(name);
	  parser.additionalTypeVariables.put(name, mtv);
	  // have to wait until we see the name of the method and create
	  // the methodDoc before we can add set the declaringMethod field
	  // this will be done in postTypeParam()
      }
  }
  void addTypeVariableBounds(String name, List<Type> bounds) {
      // find the type variable corresponding to 'name'.
      assert parser.additionalTypeVariables.containsKey(name);
      PTypeVariable tv = parser.additionalTypeVariables.get(name);
      // if bounds list is zero-length, fabricate a one-element list
      // with the type for java.lang.Object.
      if (bounds.size()==0)
	  bounds = new TypeList(eagerClassType("java.lang","Object"));
      // add bounds to type variable.
      tv.addBounds(bounds);
  }
  Type arrayType(Type ty, int dims) {
      assert dims>=0;
      return (dims==0) ? ty : new PArrayType(ty, dims);
  }
  static class PParameterList extends ArrayList<PParameter> {
      PParameterList() { super(1); }
      PParameterList(PParameter p) { super(2); add(p); }
  }
  static class TypeList extends ArrayList<Type> {
	TypeList() { super(1); }
	TypeList(Type ty) { super(2); add(ty); }
  }
  static class TypeArgumentList extends ArrayList<TypeArgument> {
	TypeArgumentList() { super(1); }
	TypeArgumentList(TypeArgument arg) { super(2); add(arg); }
  }
  static class VariableDeclarator {
      final String name; final int pos;
      // keep track of last comment seen prior to this declarator.
      final String comment; final PSourcePosition commentPos;
      int dims=0;
      VariableDeclarator(String name, int pos, Java15 parser) {
	  this.name = name; this.pos = pos;
	  // keep track of last comment seen prior to this. 
	  this.comment = parser.lexer.lastComment();
	  this.commentPos = parser.sp(parser.lexer.lastCommentPos());
      }
  }
  static class VariableDeclaratorList extends ArrayList<VariableDeclarator> {
      VariableDeclaratorList(VariableDeclarator vd) { super(2); add(vd); }
  }
  static class MethodDeclarator {
      final String name; final int pos;
      final List<PParameter> parameters;
      int dims=0;
      MethodDeclarator(String name, int pos, List<PParameter> parameters) {
	  this.name = name; this.pos = pos; this.parameters = parameters;
      }
  }
:};

scan with {: return lexer.nextToken(); :};

terminal BOOLEAN; // primitive_type
terminal BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal FLOAT, DOUBLE; // floating_point_type
terminal LBRACK, RBRACK; // array_type
terminal java.lang.String IDENTIFIER; // name
terminal DOT; // qualified_name
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal PACKAGE; // package_declaration
terminal IMPORT; // import_declaration
terminal PUBLIC, PROTECTED, PRIVATE; // modifier
terminal STATIC; // modifier
terminal ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal CLASS; // class_declaration
terminal EXTENDS; // super
terminal IMPLEMENTS; // interfaces
terminal VOID; // method_header
terminal THROWS; // throws
terminal THIS, SUPER; // explicit_constructor_invocation
terminal INTERFACE; // interface_declaration
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal SWITCH; // switch_statement
terminal CASE, DEFAULT; // switch_label
terminal DO, WHILE; // while_statement, do_statement
terminal FOR; // for_statement
terminal BREAK; // break_statement
terminal CONTINUE; // continue_statement
terminal RETURN; // return_statement
terminal THROW; // throw_statement
terminal TRY; // try_statement
terminal CATCH; // catch_clause
terminal FINALLY; // finally
terminal NEW; // class_instance_creation_expression
terminal PLUSPLUS; // postincrement_expression
terminal MINUSMINUS; // postdecrement_expression
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal AND; // and_expression
terminal XOR; // exclusive_or_expression
terminal OR;  // inclusive_or_expression
terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression
terminal QUESTION; // conditional_expression
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal ANDEQ, XOREQ, OREQ; // assignment_operator

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;

// Reserved but unused:
terminal CONST, GOTO;
// strictfp keyword, new in Java 1.2
terminal STRICTFP;
// assert keyword, new in Java 1.4
terminal ASSERT; // assert_statement
// ellipsis token for varargs, new in Java 1.5 (JSR-201)
terminal ELLIPSIS;
// enum keyword, new in Java 1.5 (JSR-201)
terminal ENUM;

// 19.2) The Syntactic Grammar
non terminal PCompilationUnit goal;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal Type type, reference_type;
non terminal PClassType primitive_type, numeric_type;
non terminal PClassType integral_type, floating_point_type;
non terminal Type class_or_interface_type;
non terminal Type class_type, interface_type;
non terminal Type array_type;
// 19.5) Names
non terminal String name, simple_name, qualified_name;
// 19.6) Packages
non terminal compilation_unit;
non terminal String package_declaration_opt, package_declaration;
non terminal import_declarations_opt, import_declarations;
non terminal type_declarations_opt, type_declarations;
non terminal import_declaration;
non terminal single_type_import_declaration;
non terminal type_import_on_demand_declaration;
non terminal static_single_type_import_declaration;
non terminal static_type_import_on_demand_declaration;
non terminal type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal Integer modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal class_declaration, super_opt;
non terminal Type super;
non terminal TypeList interfaces, interface_type_list;
non terminal interfaces_opt;
non terminal class_body;
non terminal class_body_declarations, class_body_declarations_opt;
non terminal class_body_declaration, class_member_declaration;
// JSR-201) Enum Declaration
non terminal enum_declaration;
non terminal enum_body, enum_constants_opt, enum_constants, enum_constant;
non terminal enum_arguments_opt, enum_body_declarations_opt;
// 19.8.2) Field Declarations
non terminal field_declaration;
non terminal VariableDeclaratorList variable_declarators;
non terminal VariableDeclarator variable_declarator, variable_declarator_id;
non terminal variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header;
non terminal MethodDeclarator method_declarator;
non terminal PParameterList formal_parameter_list_opt, formal_parameter_list;
non terminal PParameter formal_parameter;
non terminal TypeList throws_opt, throws, class_type_list;
non terminal method_body;
// 19.8.4) Static Initializers
non terminal static_initializer;
// 19.8.5) Constructor Declarations
non terminal constructor_declaration;
non terminal MethodDeclarator constructor_declarator;
non terminal constructor_body;
non terminal explicit_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal interface_declaration;
non terminal extends_interfaces_opt, extends_interfaces;
non terminal interface_body;
non terminal interface_member_declarations_opt, interface_member_declarations;
non terminal interface_member_declaration, constant_declaration;
non terminal abstract_method_declaration;
// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement, statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal labeled_statement, labeled_statement_no_short_if;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal switch_statement, switch_block;
non terminal switch_block_statement_groups;
non terminal switch_block_statement_group;
non terminal switch_labels, switch_label;
non terminal while_statement, while_statement_no_short_if;
non terminal do_statement;
non terminal foreach_statement, foreach_statement_no_short_if;
non terminal for_statement, for_statement_no_short_if;
non terminal for_init_opt, for_init;
non terminal for_update_opt, for_update;
non terminal statement_expression_list;
non terminal identifier_opt;
non terminal break_statement, continue_statement;
non terminal return_statement, throw_statement;
non terminal synchronized_statement, try_statement;
non terminal catches_opt, catches, catch_clause;
non terminal finally;
non terminal assert_statement;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal class_instance_creation_expression;
non terminal argument_list_opt, argument_list;
non terminal array_creation_init, array_creation_uninit;
non terminal dim_exprs, dim_expr;
non terminal Integer dims_opt, dims;
non terminal field_access, method_invocation, array_access;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal shift_expression, relational_expression, equality_expression;
non terminal and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal assignment_operator;
non terminal expression_opt, expression;
non terminal constant_expression;
// JSR-14 2.1) Type Syntax 2.3) Handling Consecutive Type Brackets
non terminal Type class_or_interface;
non terminal String type_variable;
non terminal TypeArgumentList type_arguments, type_arguments_opt;
non terminal TypeArgumentList type_argument_list;
non terminal TypeArgumentList type_argument_list_1;
non terminal TypeArgumentList type_argument_list_2;
non terminal TypeArgumentList type_argument_list_3;
non terminal Type reference_type_1, reference_type_2, reference_type_3;
// JSR-14 2.2) Parameterized Type Declarations 2.3) Handling Consecutive...
non terminal type_parameters, type_parameters_opt;
non terminal type_parameter, type_parameter_list;
non terminal type_parameter_1, type_parameter_list_1;
non terminal TypeList type_bound, type_bound_opt;
non terminal TypeList type_bound_1;
non terminal TypeList additional_bound_list, additional_bound_list_opt;
non terminal TypeList additional_bound_list_1;
non terminal Type additional_bound, additional_bound_1;
non terminal TypeArgument wildcard, wildcard_1, wildcard_2, wildcard_3;
non terminal TypeArgument type_argument, type_argument_1, type_argument_2, type_argument_3;
// not mentioned in JSR-14: need to reduce the precedence of instanceof
// Alternatively, you can tweak the relational_expression production a little.
non terminal instanceof_expression;
//// expressions which are Not a Name
non terminal postfix_expression_nn;
non terminal unary_expression_nn;
non terminal unary_expression_not_plus_minus_nn;
non terminal multiplicative_expression_nn;
non terminal additive_expression_nn;
non terminal shift_expression_nn;
non terminal relational_expression_nn;
non terminal instanceof_expression_nn;
non terminal equality_expression_nn;
non terminal and_expression_nn;
non terminal exclusive_or_expression_nn;
non terminal inclusive_or_expression_nn;
non terminal conditional_and_expression_nn;
non terminal conditional_or_expression_nn;
non terminal conditional_expression_nn;
non terminal assignment_expression_nn;
non terminal expression_nn;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=	compilation_unit
		{: RESULT=parser.compilationUnit; :}
	;

// 19.3) Lexical Structure.
literal ::=	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	CHARACTER_LITERAL
	|	STRING_LITERAL
	|	NULL_LITERAL
	;

// 19.4) Types, Values, and Variables
type	::=	primitive_type:ty
		{: RESULT=ty; :}
	|	reference_type:ty
		{: RESULT=ty; :}
	;
primitive_type ::=
		numeric_type:ty
		{: RESULT=ty; :}
	|	BOOLEAN
		{: RESULT=parser.rootDoc.pc.BOOLEAN; :}
	;
numeric_type::=	integral_type:ty
		{: RESULT=ty; :}
	|	floating_point_type:ty
		{: RESULT=ty; :}
	;
integral_type ::= 
		BYTE 
		{: RESULT=parser.rootDoc.pc.BYTE; :}
	|	SHORT 
		{: RESULT=parser.rootDoc.pc.SHORT; :}
	|	INT 
		{: RESULT=parser.rootDoc.pc.INT; :}
	|	LONG 
		{: RESULT=parser.rootDoc.pc.LONG; :}
	|	CHAR 
		{: RESULT=parser.rootDoc.pc.CHAR; :}
	;
floating_point_type ::= 
		FLOAT 
		{: RESULT=parser.rootDoc.pc.FLOAT; :}
	|	DOUBLE
		{: RESULT=parser.rootDoc.pc.DOUBLE; :}
	;

reference_type ::=
		class_or_interface_type:ty
		{: RESULT=ty; :}
/* note that the 'type_variable' production will come out of the grammar
 * as a 'class_or_interface_type' with a 'simple_name'.  The semantic
 * checker will have to resolve whether this is a class name or a type
 * variable */
	|	array_type:ty
		{: RESULT=ty; :}
	;
type_variable ::=
		IDENTIFIER:id
		{: RESULT=id; addTypeVariable(id); :}
	;
class_or_interface ::=
		name:n
		{: RESULT = lookupType(n); /* could be a type variable */ :}
	|	class_or_interface:ty LT:l type_argument_list_1:args DOT name:n
		{: ParameterizedType pt = addParams(ty, args, lleft);
		   RESULT = joinWithParam(pt, n); :}
	;
class_or_interface_type ::=
		class_or_interface:ty
		{: RESULT = ty; :}
	|	class_or_interface:ty LT:l type_argument_list_1:args
		{: RESULT = addParams(ty, args, lleft); :}
	;

class_type ::=	class_or_interface_type:ty
		{: RESULT=ty; :}
	;
interface_type ::= class_or_interface_type:ty
		{: RESULT=ty; :}
	;

array_type ::=	primitive_type:ty dims:d
		{: RESULT=arrayType(ty, d.intValue()); :}
	// we have class_or_interface_type here even though only unbounded
	// wildcards are really allowed in the parameterization.
	// we have to expand this to avoid lookahead problems.
	|	name:n dims:d
		{: RESULT=arrayType(lookupType(n), d.intValue()); :}
	|	class_or_interface:ty LT:l type_argument_list_1:args DOT name:n
			dims:d
		{: RESULT=arrayType(joinWithParam(addParams(ty, args, lleft),
						  n), d.intValue()); :}
	|	class_or_interface:ty LT:l type_argument_list_1:args dims:d
		{: RESULT=arrayType(addParams(ty,args,lleft), d.intValue()); :}
	;

type_arguments_opt ::= type_arguments:tl
		{: RESULT=tl; :}
	|
		{: RESULT=new TypeArgumentList(); :}
	;

type_arguments ::=
		LT type_argument_list_1:args
		{: RESULT=args; :}
	;
wildcard ::=	QUESTION
		{: RESULT=new PTypeArgument
		          (eagerClassType("java.lang","Object"), true, true); :}
	|	QUESTION EXTENDS reference_type:ty
		{: RESULT=new PTypeArgument(ty, true, false); :}
	|	QUESTION SUPER reference_type:ty
		{: RESULT=new PTypeArgument(ty, false, true); :}
	;
wildcard_1 ::=	QUESTION GT
		{: RESULT=new PTypeArgument
		          (eagerClassType("java.lang","Object"), true, true); :}
	|	QUESTION EXTENDS reference_type_1:ty
		{: RESULT=new PTypeArgument(ty, true, false); :}
	|	QUESTION SUPER reference_type_1:ty
		{: RESULT=new PTypeArgument(ty, false, true); :}
	;
wildcard_2 ::=	QUESTION RSHIFT
		{: RESULT=new PTypeArgument
		          (eagerClassType("java.lang","Object"), true, true); :}
	|	QUESTION EXTENDS reference_type_2:ty
		{: RESULT=new PTypeArgument(ty, true, false); :}
	|	QUESTION SUPER reference_type_2:ty
		{: RESULT=new PTypeArgument(ty, false, true); :}
	;
wildcard_3 ::=	QUESTION URSHIFT
		{: RESULT=new PTypeArgument
		          (eagerClassType("java.lang","Object"), true, true); :}
	|	QUESTION EXTENDS reference_type_3:ty
		{: RESULT=new PTypeArgument(ty, true, false); :}
	|	QUESTION SUPER reference_type_3:ty
		{: RESULT=new PTypeArgument(ty, false, true); :}
	;
reference_type_1 ::=
		reference_type:ty GT
		{: RESULT=ty; :}
	|	class_or_interface:ty LT:l type_argument_list_2:args
		{: RESULT=addParams(ty, args, lleft); :}
	;
reference_type_2 ::=
		reference_type:ty RSHIFT
		{: RESULT=ty; :}
	|	class_or_interface:ty LT:l type_argument_list_3:args
		{: RESULT=addParams(ty, args, lleft); :}
	;
reference_type_3 ::=
		reference_type:ty URSHIFT
		{: RESULT=ty; :}
	;
type_argument_list ::=
		type_argument:a
		{: RESULT=new TypeArgumentList(a); :}
	|	type_argument_list:args COMMA type_argument:a
		{: args.add(a); RESULT=args; :}
	;
type_argument_list_1 ::=
		type_argument_1:a
		{: RESULT=new TypeArgumentList(a); :}
	|	type_argument_list:args COMMA type_argument_1:a
		{: args.add(a); RESULT=args; :}
	;
type_argument_list_2 ::=
		type_argument_2:a
		{: RESULT=new TypeArgumentList(a); :}
	|	type_argument_list:args COMMA type_argument_2:a
		{: args.add(a); RESULT=args; :}
	;
type_argument_list_3 ::=
		type_argument_3:a
		{: RESULT=new TypeArgumentList(a); :}
	|	type_argument_list:args COMMA type_argument_3:a
		{: args.add(a); RESULT=args; :}
	;
type_argument ::=
		reference_type:ty
		{: RESULT=new PTypeArgument(ty, false, false); :}
	|	wildcard:arg
		{: RESULT=arg; :}
	;
type_argument_1 ::=
		reference_type_1:ty
		{: RESULT=new PTypeArgument(ty, false, false); :}
	|	wildcard_1:arg
		{: RESULT=arg; :}
	;
type_argument_2 ::=
		reference_type_2:ty
		{: RESULT=new PTypeArgument(ty, false, false); :}
	|	wildcard_2:arg
		{: RESULT=arg; :}
	;
type_argument_3 ::=
		reference_type_3:ty
		{: RESULT=new PTypeArgument(ty, false, false); :}
	|	wildcard_3:arg
		{: RESULT=arg; :}
	;

// 19.5) Names
name	::=	simple_name:n
		{: RESULT=n; :}
	|	qualified_name:n
		{: RESULT=n; :}
	;
simple_name ::=	IDENTIFIER:id
		{: RESULT=id; :}
	;
qualified_name ::=
		name:n DOT IDENTIFIER:id
		{: RESULT=combineWithDot(n,id); :}
	;

// 19.6) Packages
compilation_unit ::=
		package_declaration_opt:pkgName
		{:
		if (parser.expectedPackage!=null &&
		    !parser.expectedPackage.name().equals(pkgName)) {
		    parser.rootDoc.printError
			(sp(pkgNameleft), "Package name does not match "+
			 "sourcepath location: expected "+
			 parser.expectedPackage.name());
		    parser.expectedPackage=null;
		}
		if (parser.expectedPackage==null)
		  parser.expectedPackage=parser.rootDoc.findOrCreatePackage
			(pkgName, false/* not expected to be included*/);
		assert parser.expectedPackage!=null;
		parser.typeContexts.push(new TypeContext
		    (parser.rootDoc.pc, parser.expectedPackage,
		     parser.compilationUnit, null, null));
		:}
		import_declarations_opt
		type_declarations_opt
		;
package_declaration_opt ::=
		package_declaration:pkgName
		{: RESULT=pkgName; :}
	| /* unnamed package */
		{: RESULT=""; :}
	;
import_declarations_opt ::= import_declarations | ;
type_declarations_opt   ::= type_declarations   | ;

import_declarations ::= 
		import_declaration
	|	import_declarations import_declaration
	;
type_declarations ::= 
		type_declaration
	|	type_declarations type_declaration
	;
package_declaration ::= 
		PACKAGE name:n SEMICOLON
		{: RESULT=n; :}
	;
import_declaration ::= 
		single_type_import_declaration
	|	type_import_on_demand_declaration
	|	static_single_type_import_declaration
	|	static_type_import_on_demand_declaration
	;
single_type_import_declaration ::= 
		IMPORT name:n SEMICOLON
		{: parser.compilationUnit.singleTypeImport.add(n); :}
	;
static_single_type_import_declaration ::= 
		IMPORT STATIC name:n SEMICOLON
		{: parser.compilationUnit.staticSingleTypeImport.add(n); :}
	;
type_import_on_demand_declaration ::=
		IMPORT name:pkgName DOT MULT SEMICOLON
		{:
		 PPackageDoc pkg =
		     parser.rootDoc.findOrCreatePackage(pkgName, false);
		 parser.compilationUnit.onDemandImport.add(pkg);
		:}
	;
static_type_import_on_demand_declaration ::=
		IMPORT STATIC name:n DOT MULT SEMICOLON
		{: parser.compilationUnit.staticOnDemandImport.add(n); :}
	;
type_declaration ::=
		class_declaration
	|	enum_declaration
	|	interface_declaration
	|	SEMICOLON
	;

// 19.7) Productions used only in the LALR(1) grammar
modifiers_opt::=
		{: RESULT = new Integer(0); :}
	|	modifiers:m
		{: RESULT = m; :}
	;
modifiers ::= 	modifier:m
		{: RESULT = m; :}
	|	modifiers:m1 modifier:m2
		{: RESULT = new Integer(m1.intValue()|m2.intValue()); :}
	;
modifier ::=	PUBLIC
		{: RESULT = new Integer(Modifier.PUBLIC); :}
	|	PROTECTED 
		{: RESULT = new Integer(Modifier.PROTECTED); :}
	|	PRIVATE
		{: RESULT = new Integer(Modifier.PRIVATE); :}
	|	STATIC
		{: RESULT = new Integer(Modifier.STATIC); :}
	|	ABSTRACT
		{: RESULT = new Integer(Modifier.ABSTRACT); :}
	|	FINAL
		{: RESULT = new Integer(Modifier.FINAL); :}
	|	NATIVE
		{: RESULT = new Integer(Modifier.NATIVE); :}
	|	SYNCHRONIZED
		{: RESULT = new Integer(Modifier.SYNCHRONIZED); :}
	|	TRANSIENT
		{: RESULT = new Integer(Modifier.TRANSIENT); :}
	|	VOLATILE
		{: RESULT = new Integer(Modifier.VOLATILE); :}
	|	STRICTFP
		{: RESULT = new Integer(Modifier.STRICT); :}
	;

// 19.8) Classes

// 19.8.1) Class Declaration:
class_declaration ::= 
	modifiers_opt:m CLASS IDENTIFIER:id
		{: startTypeDeclaration(m.intValue(), id, Sym.CLASS, idleft);:}
          type_parameters_opt
		{: postTypeParam(null); :}
	  super_opt interfaces_opt
		{: preClassBody(); :}
	  class_body
		{: endTypeDeclaration(); :}
	;
super ::=	EXTENDS class_type:ty
		{: RESULT=ty; :}
	;
super_opt ::=	
		{: parser.outerClasses.peek().superclass=eagerClassType("java.lang","Object"); :}
	|	super:ty
		{: parser.outerClasses.peek().superclass=ty; :}
	;
interfaces ::=	IMPLEMENTS interface_type_list:tl
		{: RESULT=tl; :}
	;
interfaces_opt::=
	|	interfaces:tl
		{: parser.outerClasses.peek().interfaces.addAll(tl); :}
	;
interface_type_list ::= 
		interface_type:ty
		{: RESULT=new TypeList(ty); :}
	|	interface_type_list:tl COMMA interface_type:ty
		{: tl.add(ty); RESULT=tl; :}
	;
class_body ::=	LBRACE class_body_declarations_opt RBRACE 
	;
class_body_declarations_opt ::= 
	|	class_body_declarations ;
class_body_declarations ::= 
		class_body_declaration
	|	class_body_declarations class_body_declaration
	;
class_body_declaration ::=
		class_member_declaration
	|	static_initializer
	|	constructor_declaration
	|	block
	;
class_member_declaration ::=
		field_declaration
	|	method_declaration
	/* repeat the prod for 'class_declaration' here: */
	|	modifiers_opt:m CLASS IDENTIFIER:id
		{: startTypeDeclaration(m.intValue(), id, Sym.CLASS, idleft);:}
		 type_parameters_opt
		{: postTypeParam(null); :}
		 super_opt interfaces_opt
		{: preClassBody(); :}
		 class_body
		{: endTypeDeclaration(); :}
	|	enum_declaration
	|	interface_declaration
	|	SEMICOLON
	;

// JSR-201) Enum Declaration
enum_declaration ::=
		modifiers_opt:m ENUM IDENTIFIER:id
		{: startTypeDeclaration(m.intValue(), id, Sym.ENUM, idleft);
		   postTypeParam(null); :}
			interfaces_opt
		{: preClassBody(); :}
			enum_body
		{: endTypeDeclaration(); :}
	;
enum_body ::=
		LBRACE enum_constants_opt enum_body_declarations_opt RBRACE
	;
enum_constants_opt ::=
	|	enum_constants
	;
enum_constants ::=
		enum_constant
	|	enum_constants COMMA enum_constant
	;
enum_constant ::=
		IDENTIFIER:id enum_arguments_opt
		{: doEnumConstantDeclaration(id, idleft); :}
	|	IDENTIFIER:id enum_arguments_opt class_body
		{: doEnumConstantDeclaration(id, idleft); :}
	;
enum_arguments_opt ::=
	|	LPAREN argument_list_opt RPAREN
	;
enum_body_declarations_opt ::=
	|	SEMICOLON class_body_declarations_opt
	;

// 19.8.2) Field Declarations
field_declaration ::= 
		modifiers_opt:m type:ty variable_declarators:vdl
		{: doFieldDeclaration(m.intValue(), ty, vdl); :}
		SEMICOLON
	;
variable_declarators ::=
		variable_declarator:vd
    		{: RESULT=new VariableDeclaratorList(vd); :}
	|	variable_declarators:vdl COMMA variable_declarator:vd
		{: vdl.add(vd); RESULT=vdl; :}
	;
variable_declarator ::=
		variable_declarator_id:vd
		{: RESULT=vd; :}
	|	variable_declarator_id:vd EQ variable_initializer
		{: RESULT=vd; /* ignoring the initializer. */ :}
	;
variable_declarator_id ::=
		IDENTIFIER:id
    		{: RESULT=new VariableDeclarator(id, idleft, parser); :}
	|	variable_declarator_id:vd LBRACK RBRACK
		{: vd.dims++; RESULT=vd; :}
	;
variable_initializer ::=
		expression
	|	array_initializer
	;

// 19.8.3) Method Declarations
method_declaration ::=
		method_header method_body
	;
method_header ::=
	// have to expand type_parameters_opt here so that we don't
	// force an early decision of whether this is a field_declaration
	// or a method_declaration (the type_parameters_opt would have to
	// be reduced when we see the 'type' if this was a method declaration,
	// but it might still turn out to be a field declaration).
		modifiers_opt:m type:ty method_declarator:md throws_opt:thr
		{: doMethodDeclaration(m.intValue(), ty, md, thr); :}
	|	modifiers_opt:m LT type_parameter_list_1 type:ty method_declarator:md throws_opt:thr
		{: doMethodDeclaration(m.intValue(), ty, md, thr); :}
	|	modifiers_opt:m VOID method_declarator:md throws_opt:thr
		{: doMethodDeclaration(m.intValue(), null, md, thr); :}
	|	modifiers_opt:m LT type_parameter_list_1 VOID method_declarator:md throws_opt:thr
		{: doMethodDeclaration(m.intValue(), null, md, thr); :}
	;
method_declarator ::=
		IDENTIFIER:id LPAREN formal_parameter_list_opt:fpl RPAREN
    		{: RESULT=new MethodDeclarator(id,idleft,fpl); :}
	|	method_declarator:md LBRACK RBRACK // deprecated
		{: md.dims++; RESULT=md; :}
	// be careful; the above production also allows 'void foo() []'
	;
formal_parameter_list_opt ::=
		{: RESULT=new PParameterList(); :}
	|	formal_parameter_list:fpl
		{: RESULT=fpl; :}
	;
formal_parameter_list ::=
		formal_parameter:fp
		{: RESULT=new PParameterList(fp); :}
	|	formal_parameter_list:fpl COMMA formal_parameter:fp
		{: fpl.add(fp); RESULT=fpl; :}
	;
formal_parameter ::=
		type:ty variable_declarator_id:vd
    		{: RESULT=new PParameter(arrayType(ty, vd.dims), vd.name, false); :}
	|	FINAL type:ty variable_declarator_id:vd
    		{: RESULT=new PParameter(arrayType(ty, vd.dims), vd.name, false); :}
	// careful, productions below allow varargs in non-final positions.
	|	type:ty ELLIPSIS IDENTIFIER:id
		{: RESULT=new PParameter(arrayType(ty, 1), id, true); :}
	|	FINAL type:ty ELLIPSIS IDENTIFIER:id
		{: RESULT=new PParameter(arrayType(ty, 1), id, true); :}
	;
throws_opt ::=	
		{: RESULT=new TypeList(); :}
	|	throws:thr
		{: RESULT=thr; :}
	;
throws ::=	THROWS class_type_list:ctl
		{: RESULT=ctl; :}
	;
class_type_list ::=
		class_type:ty
		{: RESULT=new TypeList(ty); :}
	|	class_type_list:ctl COMMA class_type:ty
		{: ctl.add(ty); RESULT=ctl; :}
	;
method_body ::=	block
	|	SEMICOLON
	;

// 19.8.4) Static Initializers
static_initializer ::=
		STATIC block
	;

// 19.8.5) Constructor Declarations
constructor_declaration ::=
		modifiers_opt:m constructor_declarator:cd
			throws_opt:thr
		{: doMethodDeclaration(m.intValue(), null, cd, thr); :}
			constructor_body
	|	modifiers_opt:m LT type_parameter_list_1
		    constructor_declarator:cd throws_opt:thr
		{: doMethodDeclaration(m.intValue(), null, cd, thr); :}
			constructor_body
	;
constructor_declarator ::=
		simple_name:n LPAREN formal_parameter_list_opt:fpl RPAREN
		{: /* check that simple_name matches the class name */
		   if (!n.equals(parser.outerClasses.peek().name()))
		       parser.rootDoc.printError(sp(nleft),
						 "invalid method declaration;"+
						 " return type required");
		   RESULT=new MethodDeclarator(null,nleft,fpl); :}
	;
constructor_body ::=
		LBRACE explicit_constructor_invocation
			block_statements RBRACE
	|	LBRACE explicit_constructor_invocation RBRACE
	|	LBRACE block_statements RBRACE
	|	LBRACE RBRACE
	|	SEMICOLON // support stubs
	;
explicit_constructor_invocation ::=
		THIS LPAREN argument_list_opt RPAREN SEMICOLON
	|	type_arguments THIS LPAREN argument_list_opt RPAREN SEMICOLON
	|	SUPER LPAREN argument_list_opt RPAREN SEMICOLON
	|	type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
	|	primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
	|	primary DOT type_arguments SUPER
			LPAREN argument_list_opt RPAREN SEMICOLON
	|	name DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
	|	name DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
	;

// 19.9) Interfaces

// 19.9.1) Interface Declarations
interface_declaration ::=
		modifiers_opt:m INTERFACE IDENTIFIER:id
		{: startTypeDeclaration(m.intValue(), id, Sym.INTERFACE, idleft); :}
		 type_parameters_opt
		{: postTypeParam(null); :}
		 extends_interfaces_opt
		{: preClassBody(); :}
		 interface_body
		{: endTypeDeclaration(); :}
	;
extends_interfaces_opt ::=
	|	extends_interfaces
	;
extends_interfaces ::=
		EXTENDS interface_type:ty
		{: parser.outerClasses.peek().interfaces.add(ty); :}
	|	extends_interfaces COMMA interface_type:ty
		{: parser.outerClasses.peek().interfaces.add(ty); :}
	;
interface_body ::=
		LBRACE interface_member_declarations_opt RBRACE
	;
interface_member_declarations_opt ::=
	|	interface_member_declarations
	;
interface_member_declarations ::=
		interface_member_declaration
	|	interface_member_declarations interface_member_declaration
	;
interface_member_declaration ::=
		constant_declaration
	|	abstract_method_declaration
	|	class_declaration
	|	enum_declaration
	|	interface_declaration
	|	SEMICOLON
	;
constant_declaration ::=
		field_declaration
	// need to semantically check that modifiers of field declaration
	// include only PUBLIC, STATIC, or FINAL.  Other modifiers are
	// disallowed.
	;
abstract_method_declaration ::=
		method_header SEMICOLON
	;

// 19.10) Arrays
array_initializer ::=
		LBRACE variable_initializers COMMA RBRACE
	|	LBRACE variable_initializers RBRACE
	|	LBRACE COMMA RBRACE
	|	LBRACE RBRACE
	;
variable_initializers ::=
		variable_initializer
	|	variable_initializers COMMA variable_initializer
	;

// 19.11) Blocks and Statements
block ::=	LBRACE {: startUnnamedContext(); :} block_statements_opt {: endUnnamedContext(); :} RBRACE
	;
block_statements_opt ::=
	|	block_statements
	;
block_statements ::=
		block_statement
	|	block_statements block_statement
	;
block_statement ::=
		local_variable_declaration_statement
	|	statement
	|	class_declaration
	|	enum_declaration
	|	interface_declaration
	;
local_variable_declaration_statement ::=
		local_variable_declaration SEMICOLON
	;
/* jikes expands 'type' in production for local_variable_declaration to
 * avoid reduce-reduce conflict:  given 'name [' the grammar can't decide
 * whether this is going to be a type (starting the local_variable_declaration)
 * or an array access expression. */
local_variable_declaration ::=
		type variable_declarators
	// you may want to accept 'modifiers' here instead of just FINAL
	// to produce better error messages.
	|	FINAL type variable_declarators
	;
statement ::=	statement_without_trailing_substatement
	|	labeled_statement
	|	if_then_statement
	|	if_then_else_statement
	|	while_statement
	|	for_statement
	|	foreach_statement
	;
statement_no_short_if ::=
		statement_without_trailing_substatement
	|	labeled_statement_no_short_if
	|	if_then_else_statement_no_short_if
	|	while_statement_no_short_if
	|	for_statement_no_short_if
	|	foreach_statement_no_short_if
	;
statement_without_trailing_substatement ::=
		block
	|	empty_statement
	|	expression_statement
	|	switch_statement
	|	do_statement
	|	break_statement
	|	continue_statement
	|	return_statement
	|	synchronized_statement
	|	throw_statement
	|	try_statement
	|	assert_statement
	;
empty_statement ::=
		SEMICOLON
	;
labeled_statement ::=
		IDENTIFIER COLON statement
	;
labeled_statement_no_short_if ::=
		IDENTIFIER COLON statement_no_short_if
	;
expression_statement ::=
		statement_expression SEMICOLON
	;
statement_expression ::=
		assignment
	|	preincrement_expression
	|	predecrement_expression
	|	postincrement_expression
	|	postdecrement_expression
	|	method_invocation
	|	class_instance_creation_expression
	;
if_then_statement ::=
		IF LPAREN expression RPAREN statement
	;
if_then_else_statement ::=
		IF LPAREN expression RPAREN statement_no_short_if 
			ELSE statement
	;
if_then_else_statement_no_short_if ::=
		IF LPAREN expression RPAREN statement_no_short_if
			ELSE statement_no_short_if
	;
switch_statement ::=
		SWITCH LPAREN expression RPAREN switch_block
	;
switch_block ::=
		LBRACE switch_block_statement_groups switch_labels RBRACE
	|	LBRACE switch_block_statement_groups RBRACE
	|	LBRACE switch_labels RBRACE
	|	LBRACE RBRACE
	;
switch_block_statement_groups ::=
		switch_block_statement_group
	|	switch_block_statement_groups switch_block_statement_group
	;
switch_block_statement_group ::=
		switch_labels block_statements
	;
switch_labels ::=
		switch_label
	|	switch_labels switch_label
	;
switch_label ::=
		CASE constant_expression COLON
	|	DEFAULT COLON
	;

while_statement ::=
		WHILE LPAREN expression RPAREN statement
	;
while_statement_no_short_if ::=
		WHILE LPAREN expression RPAREN statement_no_short_if
	;
do_statement ::=
		DO statement WHILE LPAREN expression RPAREN SEMICOLON
	;
foreach_statement ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement
	;
foreach_statement_no_short_if ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement_no_short_if
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement_no_short_if
	;
for_statement ::=
		FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON
			for_update_opt RPAREN statement
	;
for_statement_no_short_if ::=
		FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON
			for_update_opt RPAREN statement_no_short_if
	;
for_init_opt ::=
	|	for_init
	;
for_init ::=	statement_expression_list
	|	local_variable_declaration
	;
for_update_opt ::=
	|	for_update
	;
for_update ::=	statement_expression_list
	;
statement_expression_list ::=
		statement_expression
	|	statement_expression_list COMMA statement_expression
	;

identifier_opt ::= 
	|	IDENTIFIER
	;

break_statement ::=
		BREAK identifier_opt SEMICOLON
	;

continue_statement ::=
		CONTINUE identifier_opt SEMICOLON
	;
return_statement ::=
		RETURN expression_opt SEMICOLON
	;
throw_statement ::=
		THROW expression SEMICOLON
	;
synchronized_statement ::=
		SYNCHRONIZED LPAREN expression RPAREN block
	;
try_statement ::=
		TRY block catches
	|	TRY block catches_opt finally
	;
catches_opt ::=
	|	catches
	;
catches ::=	catch_clause
	|	catches catch_clause
	;
catch_clause ::=
		CATCH LPAREN formal_parameter RPAREN block
	;
finally ::=	FINALLY block
	;
assert_statement ::=
		ASSERT expression SEMICOLON
	|	ASSERT expression COLON expression SEMICOLON
	;

// 19.12) Expressions
primary ::=	primary_no_new_array
	|	array_creation_init
	|	array_creation_uninit
	;
primary_no_new_array ::=
		literal
	|	THIS
	|	LPAREN name RPAREN
	|	LPAREN expression_nn RPAREN
	|	class_instance_creation_expression
	|	field_access
	|	method_invocation
	|	array_access
	|	name DOT THIS
	|	VOID DOT CLASS
	// "Type DOT CLASS", but expanded
	|	primitive_type DOT CLASS
	|	primitive_type dims DOT CLASS
	|	name DOT CLASS
	|	name dims DOT CLASS
//	the following two productions are part of the expansion of
//	'type DOT CLASS' but are not actually allowed, as they involve params.
//	[see msg from Neal Gafter <3F219367.3070903@sun.com> 25-jul-2003]
//	|	class_or_interface type_arguments DOT name dims DOT CLASS
//	|	class_or_interface LT type_argument_list_1 dims DOT CLASS
	;
// grammar distributed with prototype 2.2 is in error; the following is correct
//  [ Neal Gafter, <3F2577E0.3090008@sun.com> ]
class_instance_creation_expression ::=
		NEW class_or_interface_type LPAREN argument_list_opt RPAREN
	|	NEW class_or_interface_type:ty LPAREN argument_list_opt RPAREN
		{: startUnnamedContext();
		   startTypeDeclaration(0, newAnonClassName(), Sym.CLASS, tyleft);
		   postTypeParam(null);
		   preClassBody(); :}
		class_body
		{: endTypeDeclaration(); endUnnamedContext(); :}
	|	NEW type_arguments class_or_interface_type LPAREN argument_list_opt RPAREN
	|	NEW type_arguments class_or_interface_type:ty LPAREN argument_list_opt RPAREN
		{: startUnnamedContext();
		   startTypeDeclaration(0, newAnonClassName(), Sym.CLASS, tyleft);
		   postTypeParam(null);
		   preClassBody(); :}
		class_body
		{: endTypeDeclaration(); endUnnamedContext(); :}
	|	primary DOT NEW type_arguments_opt IDENTIFIER type_arguments_opt
			LPAREN argument_list_opt RPAREN
	|	primary DOT NEW type_arguments_opt IDENTIFIER:id type_arguments_opt
			LPAREN argument_list_opt RPAREN
		{: startUnnamedContext();
		   startTypeDeclaration(0, newAnonClassName(), Sym.CLASS, idleft);
		   postTypeParam(null);
		   preClassBody(); :}
		class_body
		{: endTypeDeclaration(); endUnnamedContext(); :}
	|	name DOT NEW type_arguments_opt IDENTIFIER type_arguments_opt
			LPAREN argument_list_opt RPAREN
	|	name DOT NEW type_arguments_opt IDENTIFIER:id type_arguments_opt
			LPAREN argument_list_opt RPAREN
		{: startUnnamedContext();
		   startTypeDeclaration(0, newAnonClassName(), Sym.CLASS, idleft);
		   postTypeParam(null);
		   preClassBody(); :}
		class_body
		{: endTypeDeclaration(); endUnnamedContext(); :}
	;
argument_list_opt ::=
	|	argument_list
	;
argument_list ::=
		expression
	|	argument_list COMMA expression
	;
array_creation_uninit ::=
		NEW primitive_type dim_exprs dims_opt
	|	NEW class_or_interface_type dim_exprs dims_opt
	;
array_creation_init ::=
		NEW primitive_type dims array_initializer
	|	NEW class_or_interface_type dims array_initializer
	;
dim_exprs ::=	dim_expr
	|	dim_exprs dim_expr
	;
dim_expr ::=	LBRACK expression RBRACK
	;
dims_opt ::=
		{: RESULT=new Integer(0); :}
	|	dims:d
		{: RESULT=d; :}
	;
dims ::=	LBRACK RBRACK
		{: RESULT=new Integer(1); :}
	|	dims:d LBRACK RBRACK
		{: RESULT=new Integer(d.intValue()+1); :}
	;
field_access ::=
		primary DOT IDENTIFIER
	|	SUPER DOT IDENTIFIER
	|	name DOT SUPER DOT IDENTIFIER
	;
method_invocation ::=
		name LPAREN argument_list_opt RPAREN
// the following production appeared in the prototype 2.2 spec, but it
// introduces ambiguities in the grammar (consider the expression
//          A((B)<C,D>E());
// which could be either an invocation on E or two boolean comparisons).
// Neal Gafter has assured me that this production should be removed
// from the grammar. <3F256C06.7000600@sun.com>
//	|	type_arguments name LPAREN argument_list_opt RPAREN
	|	primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN
	|	primary DOT type_arguments IDENTIFIER LPAREN argument_list_opt RPAREN
	|	name DOT type_arguments IDENTIFIER LPAREN argument_list_opt RPAREN
	|	SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN
	|	SUPER DOT type_arguments IDENTIFIER LPAREN argument_list_opt RPAREN
	|	name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN
	|	name DOT SUPER DOT type_arguments IDENTIFIER LPAREN argument_list_opt RPAREN
	;
array_access ::=
		name LBRACK expression RBRACK
	|	primary_no_new_array LBRACK expression RBRACK
	|	array_creation_init LBRACK expression RBRACK
	;
postfix_expression ::=
		primary
	|	name
	|	postincrement_expression
	|	postdecrement_expression
	;
postincrement_expression ::=
		postfix_expression PLUSPLUS
	;
postdecrement_expression ::=
		postfix_expression MINUSMINUS
	;
unary_expression ::=
		preincrement_expression
	|	predecrement_expression
	|	PLUS unary_expression
	|	MINUS unary_expression
	|	unary_expression_not_plus_minus
	;
preincrement_expression ::=
		PLUSPLUS unary_expression
	;
predecrement_expression ::=
		MINUSMINUS unary_expression
	;
unary_expression_not_plus_minus ::=
		postfix_expression
	|	COMP unary_expression
	|	NOT unary_expression
	|	cast_expression
	;
// This parsing technique was discovered by Eric Blake <ebb9@email.byu.edu>
// We solve grammar ambiguities between parenthesized less-than
// relational operations and type casts with a slightly-more-complicated
// cast_expression production.
// Illustrative example:  LPAREN name LT name ...
//   Is this going to be a cast_expression or a relational_expression?
// Canonically, the cast_expression production is:
//     cast_expression ::= LPAREN type RPAREN unary_expression_not_plus_minus
cast_expression ::=
		LPAREN primitive_type dims_opt RPAREN unary_expression
	|	LPAREN name RPAREN unary_expression_not_plus_minus
	|	LPAREN name dims RPAREN unary_expression_not_plus_minus
	|	LPAREN name LT type_argument_list_1 dims_opt RPAREN
			unary_expression_not_plus_minus
	|	LPAREN name LT type_argument_list_1 DOT
			class_or_interface_type dims_opt RPAREN
			unary_expression_not_plus_minus
	;
multiplicative_expression ::=
		unary_expression
	|	multiplicative_expression MULT unary_expression
	|	multiplicative_expression DIV unary_expression
	|	multiplicative_expression MOD unary_expression
	;
additive_expression ::=
		multiplicative_expression
	|	additive_expression PLUS multiplicative_expression
	|	additive_expression MINUS multiplicative_expression
	;
shift_expression ::=
		additive_expression
	|	shift_expression LSHIFT additive_expression
	|	shift_expression RSHIFT additive_expression
	|	shift_expression URSHIFT additive_expression
	;
relational_expression ::=
		shift_expression
	|	relational_expression LT shift_expression
	|	relational_expression GT shift_expression
	|	relational_expression LTEQ shift_expression
	|	relational_expression GTEQ shift_expression
	;
// we lower the precendence of instanceof to resolve a grammar ambiguity.
// semantics are unchanged, since relational expressions do not operate
// on boolean.  Eric Blake had a different solution here, where he
// used the production 'shift_expression LT shift_expression' to solve
// the same problem.
instanceof_expression ::=
		relational_expression
	|	instanceof_expression INSTANCEOF reference_type
	;
equality_expression ::=
		instanceof_expression
	|	equality_expression EQEQ instanceof_expression
	|	equality_expression NOTEQ instanceof_expression
	;
and_expression ::=
		equality_expression
	|	and_expression AND equality_expression
	;
exclusive_or_expression ::=
		and_expression
	|	exclusive_or_expression XOR and_expression
	;
inclusive_or_expression ::=
		exclusive_or_expression
	|	inclusive_or_expression OR exclusive_or_expression
	;
conditional_and_expression ::=
		inclusive_or_expression
	|	conditional_and_expression ANDAND inclusive_or_expression
	;
conditional_or_expression ::=
		conditional_and_expression
	|	conditional_or_expression OROR conditional_and_expression
	;
conditional_expression ::=
		conditional_or_expression
	|	conditional_or_expression QUESTION expression 
			COLON conditional_expression
	;
assignment_expression ::=
		conditional_expression
	|	assignment
	;
// semantic check necessary here to ensure a valid left-hand side.
// allowing a parenthesized variable here on the lhs was introduced in
// JLS 2; thanks to Eric Blake for pointing this out.
assignment ::=	postfix_expression assignment_operator assignment_expression
	;
assignment_operator ::=
		EQ
	|	MULTEQ
	|	DIVEQ
	|	MODEQ
	|	PLUSEQ
	|	MINUSEQ
	|	LSHIFTEQ
	|	RSHIFTEQ
	|	URSHIFTEQ
	|	ANDEQ
	|	XOREQ
	|	OREQ
	;
expression_opt ::=
	|	expression
	;
expression ::=	assignment_expression
	;
// note that this constraint must be enforced during semantic checking
// 'constant_expression' should include enumerated constants.
constant_expression ::=
		expression
	;

// JLS-14 productions.
type_parameters_opt ::= type_parameters | ;
type_parameters ::=
		LT type_parameter_list_1
	;
type_parameter_list ::=
		type_parameter_list COMMA type_parameter
	|	type_parameter
	;
type_parameter_list_1 ::=
		type_parameter_1
		{: parser.inTypeParamDecl=false; :}
	|	type_parameter_list COMMA type_parameter_1
		{: parser.inTypeParamDecl=false; :}
	;
type_parameter ::=
		type_variable:id type_bound_opt:tl
		{: addTypeVariableBounds(id, tl); :}
	;
type_parameter_1 ::=
		type_variable:id GT
		{: addTypeVariableBounds(id, new TypeList()); :}
	|	type_variable:id type_bound_1:tl
		{: addTypeVariableBounds(id, tl); :}
	;
type_bound_opt ::= type_bound:tl
		{: RESULT=tl; :}
	|
		{: RESULT=new TypeList(); :}
	;
type_bound ::=
		EXTENDS reference_type:ty additional_bound_list_opt:tl
		{: RESULT=new TypeList(ty); RESULT.addAll(tl); :}
	;
type_bound_1 ::=
		EXTENDS reference_type_1:ty
		{: RESULT=new TypeList(ty); :}
	|	EXTENDS reference_type:ty additional_bound_list_1:tl
		{: RESULT=new TypeList(ty); RESULT.addAll(tl); :}
	;
additional_bound_list_opt ::= additional_bound_list:tl
		{: RESULT=tl; :}
	|
		{: RESULT=new TypeList(); :}
	;
additional_bound_list ::=
		additional_bound:ty additional_bound_list:tl
		{: RESULT=new TypeList(ty); RESULT.addAll(tl); :}
	|	additional_bound:ty
		{: RESULT=new TypeList(ty); :}
	;
additional_bound_list_1 ::=
		additional_bound:ty additional_bound_list_1:tl
		{: RESULT=new TypeList(ty); RESULT.addAll(tl); :}
	|	additional_bound_1:ty
		{: RESULT=new TypeList(ty); :}
	;
additional_bound ::=
		AND interface_type:ty
		{: RESULT=ty; :}
	;
additional_bound_1 ::=
		AND reference_type_1:ty
		{: RESULT=ty; :}
	;
//////////////////////////////////////////////
// the following productions are copied from the standard ones, but
// 'name' all alone is not allowed.  The '_nn' stands for 'not name'.
// we also expand the productions so that they recursively depend on the
// '_nn' forms of their left hand side, then adding a new production
// with 'name' explicit on the left-hand side.
// this allows us to postpone the decision whether '(x)' is an expression
// or a type-cast until we can see enough right context to make the proper
// choice.
postfix_expression_nn ::=
		primary
	// the 'name' production was removed here.
	|	postincrement_expression
	|	postdecrement_expression
	;
unary_expression_nn ::=
		preincrement_expression
	|	predecrement_expression
	|	PLUS unary_expression
	|	MINUS unary_expression
	|	unary_expression_not_plus_minus_nn
	;
unary_expression_not_plus_minus_nn ::=
		postfix_expression_nn
	|	COMP unary_expression
	|	NOT unary_expression
	|	cast_expression
	;
multiplicative_expression_nn ::=
		unary_expression_nn
	|	name                         MULT unary_expression
	|	multiplicative_expression_nn MULT unary_expression
	|	name                         DIV unary_expression
	|	multiplicative_expression_nn DIV unary_expression
	|	name                         MOD unary_expression
	|	multiplicative_expression_nn MOD unary_expression
	;
additive_expression_nn ::=
		multiplicative_expression_nn
	|	name                   PLUS multiplicative_expression
	|	additive_expression_nn PLUS multiplicative_expression
	|	name                   MINUS multiplicative_expression
	|	additive_expression_nn MINUS multiplicative_expression
	;
shift_expression_nn ::=
		additive_expression_nn
	|	name                LSHIFT additive_expression
	|	shift_expression_nn LSHIFT additive_expression
	|	name                RSHIFT additive_expression
	|	shift_expression_nn RSHIFT additive_expression
	|	name                URSHIFT additive_expression
	|	shift_expression_nn URSHIFT additive_expression
	;
relational_expression_nn ::=
		shift_expression_nn
	// note that we've tweaked the productions for LT/GT to disallow
	//  a<b<c as a valid expression.  This avoids ambiguity with
	//  parameterized types in casts.
	|	name                LT shift_expression
	|	shift_expression_nn LT shift_expression
	|	name                GT shift_expression
	|	shift_expression_nn GT shift_expression
	|	name                     LTEQ shift_expression
	|	relational_expression_nn LTEQ shift_expression
	|	name                     GTEQ shift_expression
	|	relational_expression_nn GTEQ shift_expression
	;
instanceof_expression_nn ::=
		relational_expression_nn
	|	name                     INSTANCEOF reference_type
	|	instanceof_expression_nn INSTANCEOF reference_type
	;
equality_expression_nn ::=
		instanceof_expression_nn
	|	name                   EQEQ instanceof_expression
	|	equality_expression_nn EQEQ instanceof_expression
	|	name                   NOTEQ instanceof_expression
	|	equality_expression_nn NOTEQ instanceof_expression
	;
and_expression_nn ::=
		equality_expression_nn
	|	name              AND equality_expression
	|	and_expression_nn AND equality_expression
	;
exclusive_or_expression_nn ::=
		and_expression_nn
	|	name                       XOR and_expression
	|	exclusive_or_expression_nn XOR and_expression
	;
inclusive_or_expression_nn ::=
		exclusive_or_expression_nn
	|	name                       OR exclusive_or_expression
	|	inclusive_or_expression_nn OR exclusive_or_expression
	;
conditional_and_expression_nn ::=
		inclusive_or_expression_nn
	|	name                          ANDAND inclusive_or_expression
	|	conditional_and_expression_nn ANDAND inclusive_or_expression
	;
conditional_or_expression_nn ::=
		conditional_and_expression_nn
	|	name                         OROR conditional_and_expression
	|	conditional_or_expression_nn OROR conditional_and_expression
	;
conditional_expression_nn ::=
		conditional_or_expression_nn
	|	name QUESTION expression COLON conditional_expression
	|	conditional_or_expression_nn QUESTION expression 
			COLON conditional_expression
	;
assignment_expression_nn ::=
		conditional_expression_nn
	|	assignment
	;
expression_nn ::=	assignment_expression_nn
	;
